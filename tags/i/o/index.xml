<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I/O on 🌏 ZackYJ&#39;s Blog</title>
    <link>https://zackyjz.github.io/tags/i/o/</link>
    <description>Recent content in I/O on 🌏 ZackYJ&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language><atom:link href="https://zackyjz.github.io/tags/i/o/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 四种本地文件拷贝方式比较和测试</title>
      <link>https://zackyjz.github.io/posts/java%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Mon, 13 Apr 2020 13:31:23 +0800</pubDate>
      
      <guid>https://zackyjz.github.io/posts/java%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/</guid>
      <description>准备工作  为了便于测试，定义一个文件拷贝的接口让测试类去继承它：
1 2 3  public interface IFileCopy { void copyFile(File source, File dest); }   无论是 Stream 还是 Channel ，用完都需要调用 close()方法关闭
为了防止重复代码，这里统一写一个关闭的方法：
1 2 3 4 5 6 7 8 9  static void close(Closeable closeable){ if(closeable != null){ try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } }   实现  不带缓冲区的流拷贝   最朴素的文件拷贝方式，不使用带任何缓冲区的流装饰
  从源文件的输入流一个字节一个字节读取
只要还有数据 （read() 返回 ≠ -1）就循环读取并写入目标文件的输出流</description>
    </item>
    
  </channel>
</rss>
