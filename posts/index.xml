<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 🌏 ZackYJ&#39;s Blog</title>
    <link>https://blog.wvuuvw.xyz/posts/</link>
    <description>Recent content in Posts on 🌏 ZackYJ&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 14 Nov 2021 11:25:05 -0400</lastBuildDate><atom:link href="https://blog.wvuuvw.xyz/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据结构：并查集介绍和实现</title>
      <link>https://blog.wvuuvw.xyz/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 14 Nov 2021 11:25:05 -0400</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AE%9E%E7%8E%B0/</guid>
      <description>并查集也叫不相交集合，是一种树状结构，适合解决集合连接等相关问题
 介绍  并查集解决的问题：
 有若干个样本a、b、c、&amp;hellip;类型假设是V 在并查集中一开始认为每个样本都在单独的集合里   并查集的三个核心操作（常数级复杂度）：
 Find(V)/findRepresent(V) 查找元素所在的集合根节点（或代表节点） boolean isSameSet（Vx，Vy） 查询样本x和样本y是否属于一个集合 void union(Vx，Vy) 把x和y各自所在集合的所有样本合并成一个集合  实现  数组实现 如果并查集中值存储整型元素，可以使用数组来实现：
 数组下标为 i 的元素为 i 的父节点
 Quick Find   Union -合并：将v1所在集合的所有元素都嫁接到v2的父节点上
  即：将下标v1的元素的值（父节点）改为下标v2元素的值（父节点）
  原来父节点是v1的节点，父节点也改为 v2
1 2 3 4 5 6 7 8 9 10 11  public void union(int v1,int v2){ int p1 = find(v1); int p2 = find(v2); if(p1 == p2) { return; } for(int i = 0;i&amp;lt;parents.</description>
    </item>
    
    <item>
      <title>SSM整合：分层配置和整合</title>
      <link>https://blog.wvuuvw.xyz/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</link>
      <pubDate>Tue, 05 Jan 2021 15:23:23 +0800</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/ssm-%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</guid>
      <description>创建 WEB 项目  Web模块支持  在 IDEA 中创建 Maven 项目，添加 web模板，或在一个普通 Maven 项目中添加 Web模块支持 右键项目 Add Framework Support   配置文件准备   [可选]mybatis-config.xml
 Mybatis 核心配置文件，最终会整合到 Spring 中配置    spring-dao：Dao 层 整合 Mybatis 层
 DTO 约束，同 spring-service  1 2 3 4 5 6 7  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/springbeans. xsd&amp;#34;&amp;gt; &amp;lt;/beans&amp;gt;     spring-service：Service 层，Spring 和配置文件
  spring-mvc：Controller 层，SpringMVC 核心配置文件</description>
    </item>
    
    <item>
      <title>转账案例-引入事务和AOP改造</title>
      <link>https://blog.wvuuvw.xyz/posts/%E8%BD%AC%E8%B4%A6%E6%A1%88%E4%BE%8B-%E5%BC%95%E5%85%A5%E4%BA%8B%E5%8A%A1%E5%92%8C-aop-%E6%94%B9%E9%80%A0/</link>
      <pubDate>Sun, 03 Jan 2021 08:31:23 +0800</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/%E8%BD%AC%E8%B4%A6%E6%A1%88%E4%BE%8B-%E5%BC%95%E5%85%A5%E4%BA%8B%E5%8A%A1%E5%92%8C-aop-%E6%94%B9%E9%80%A0/</guid>
      <description>基础功能  spring 整合 DBUtils ，实现简单的用户转账业务
  Account 实体类
1 2 3 4 5 6  public class Account { private Integer id; private String name; private Double money; // setter getter.... }     AccountDao 接口和实现类
  1 2 3 4 5 6  public interface AccountDao { // 转出操作  void out(String outUser, Double money); // 转入操作  void in(String inUser, Double money); }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  @Repository public class AccountDaoImpl implements AccountDao { @Autowired private QueryRunner queryRunner; @Override public void out(String outUser, Double money) { try { queryRunner.</description>
    </item>
    
    <item>
      <title>常见三大数据库连接池使用及工具类抽取</title>
      <link>https://blog.wvuuvw.xyz/posts/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Wed, 18 Nov 2020 11:25:05 -0400</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>DBCP DBCP 是Apache成员之一，在企业开发中也比较常见，也是tomcat内置的连接池
DBCP 工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  public class DBCPUtils { //1.</description>
    </item>
    
    <item>
      <title>自定义数据库连接池的实现</title>
      <link>https://blog.wvuuvw.xyz/posts/jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 14 Nov 2020 11:25:05 -0400</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/</guid>
      <description>背景 数据库连接池用于分配、管理和释放（归还）数据库连接对象 Connection
 有了数据库连接池，可以允许应用重复使用一个现有的数据库连接 从而避免了频繁创建和释放连接，消耗系统资源  最常用的第三方连接池有DBCP、 C3p0、Druid 等，本文实现一个具有基本功能的连接池
基本功能 JDBC 中 java.sql.DataSource 接口定义了数据库连接池的规范
 代表一个数据源，可以用于实现连接池 获取数据库连接对象的方法：Connection getConnection();  覆写这个接口中的方法，可实现基本的连接池功能：
 定义一个类，实现DataSource接口 定义一个容器，保存多个Connection连接对象 定义静态代码块，通过JDBC工具类获取多个连接保存到容器中 ==重写getConnection方法，从容器获取连接并返回== 定义getSize方法，获取容器大小并返回  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public class MyDataSource implements DataSource{ //1.定义集合容器，用于保存多个数据库连接对象  //Collections.synchronizedList可以将普通集合转成线程安全集合  private static List&amp;lt;Connection&amp;gt; pool = Collections.</description>
    </item>
    
    <item>
      <title>简易多人聊天室[2]-NIO模型实现</title>
      <link>https://blog.wvuuvw.xyz/posts/%E7%AE%80%E6%98%93%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4-nio%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 02 May 2020 13:31:23 +0800</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/%E7%AE%80%E6%98%93%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4-nio%E5%AE%9E%E7%8E%B0/</guid>
      <description>总体流程    ServerSocketChannel 注册 ACCEPT 事件监听到 Selector 中，用于监听 accept 事件
 当有一个客户端发出连接请求，服务器接收了客户端连接请求时，即触发了 ServerSocketChannel 的 accept 事件 与 BIO 模型中 ServerSocket.accept() 执行的事件相同，即接收了该客户端的连接请求    ServerSocketChannel 触发 accept 事件后，服务器端处理新建立连接的客户端
 得到客户端对应的 SocketChannel 将新连接的客户端的 SocketChannel 注册 READ 事件在 Selector 中   即让 Selector 监控客户端的 SocketChannel 是否触发 READ (可读) 事件
  触发时机：当该客户端像服务器发送了数据，其 SocketChannel 上有了可供服务器读取的数据时，触发 READ 事件
   对可读事件触发后的处理操作和 BIO 类似：读取 SocketChannel 的数据并转发给当前连接到服务器的其他客户端
但在 NIO 中，处理客户端连接的操作都是在同一个线程中进行
    注意</description>
    </item>
    
    <item>
      <title>Java 四种本地文件拷贝方式比较和测试</title>
      <link>https://blog.wvuuvw.xyz/posts/java%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Mon, 13 Apr 2020 13:31:23 +0800</pubDate>
      
      <guid>https://blog.wvuuvw.xyz/posts/java%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D/</guid>
      <description>准备工作  为了便于测试，定义一个文件拷贝的接口让测试类去继承它：
1 2 3  public interface IFileCopy { void copyFile(File source, File dest); }   无论是 Stream 还是 Channel ，用完都需要调用 close()方法关闭
为了防止重复代码，这里统一写一个关闭的方法：
1 2 3 4 5 6 7 8 9  static void close(Closeable closeable){ if(closeable != null){ try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } }   实现  不带缓冲区的流拷贝   最朴素的文件拷贝方式，不使用带任何缓冲区的流装饰
  从源文件的输入流一个字节一个字节读取
只要还有数据 （read() 返回 ≠ -1）就循环读取并写入目标文件的输出流</description>
    </item>
    
  </channel>
</rss>
